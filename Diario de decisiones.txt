Dia 1

Iré escribiendo en este fichero de texto a modo de diario para que se entiendan cuáles han sido mis procesos mentales a la hora de ir tomando decisiones y desarrollando código para el proyecto encargado.

El objetivo es crear un gestor de dispositivos IoT y un mockup de los propios dispositivos. El gestor ha de ser capaz de persistir las métricas creadas por los dispositivos y tambien gestionar algunos parametros de estos.

Para el gestor se me ocurre implementar un monolito por capas que gestione una conexion a una base de datos de MongoDB. Lo mas sencillo posible pues esto es una prueba de concepto y realmente no hay mucha mas gestion.
Para la simulacion de los dispositivos se me ocurren dos posibles soluciones: Lanzar go rutinas con configuracion previa desde el monolito o dockerizar el mockup de los dispositivos y lanzarlo a un cluster de kubernetes desde el monolito, este le otorgaria toda la configuracion necesaria a cada dispositivo a través de sus variables de entorno.

He elegido mongoDB pues los datos no guardan relacion alguna entre ellos, han de ser guardados en masa y rápido y además es posible que muten con el tiempo si nuevos atributos son añadidos.

Por el momento voy a avanzar con el monolito que es lo mas sencillo.
Comenzaré definiendo tres niveles:
- "handler" para exponer el servicio, voy a exponer una sencilla REST API por HTTP
- "usecase" para la lógica de negocio
- "repository" para el nivel de persistencia de datos

Adicionalmente he creado un repositorio llamado "adapter". Aquí tendré las implementaciones para los clientes de MongoDB y NATS. Esto me permitirá en un futuro definir interfaces dentro de mi monolito que puedan abstraer las implementaciones de la tecnologia utilizadas en el paquete auxiliar de "adapter".

Comenzando con el handler, este gestionará un servicio de gin. Quien ha de crear las dependecias usadas por todas las capas es el fichero "main.go" localizado en la raiz del proyecto.

Voy a definir primero una unica ruta GET para recibir todos los datos de un dispositivo dado su ID. Comenzaré definiendo el handler y de ahí trabajaré hacia abajo.

Para el nivel de usecase, voy a crear un fichero dentro para cada recurso que haya de ser gestionado. Por el momento solo tenemos "devices".
Lo mismo es dicho para el nivel de repository.

Ahora voy a definir lo más básico para la coleccion de adaptadores. Sinceramente haría la implementacion de la lógica de los clientes directamente sobre el nivel de repositorio pero en la descripcion del proyecto se piden tests para la plataforma y voy a necesitar "mockear" los clientes de las tecnologias externas si es el caso.

*Subida la verion v0.1 del proyecto*

No me termina de convencer esta solucion para el repositorio, seguramente segun escale surja algun problema y lo vuelva a repensar.

Ahora mismo falta una cosa, ¿Qué infomacion vamos a replicar y guardar?
Según la especificación el dispositivo reporta varias metricas a la vez. Así pues voy a definir un paquete "commons" para que sea compartido entre el monolito y los dispositivos iot.
En un escenario real este paquete "commons" yo lo publicaría como una libreria pública a parte.

No me termina de convencer que el monolito base todo su flujo sobre un tipo de datos externo, pero menos me gusta la idea de hacer pública la declaración del tipo desde el monolito.
Como este escenario es un poc, por el momento voy a dejar esto como una carpeta al mismo nivel que el repositorio.

La declaracion del tipo va a ser de ejemplo, pondré las tres métricas mencionadas en la descripción del proyecto. Más un ID único para la métrica y un "DeviceID" que indica qué dispositivo lo creó y un atributo "timestamp" para saber cuándo se generó.
Es muy posible que reaproveche este nivel lógico para definir la configuración de los dispositivos en un futuro próximo.

Acabo de caer en la cuenta de que para este proyecto se espera que todas las comunicaciones se hagan mediante NATS, tanto el publicar como consultar metricas e incluso publicar configuracion en los sensores.
Asi que voy a cambiar la tecnologia REST API por HTTP en el nivel del handler y voy a poner un cliente de NATS que capture mensajes de un stream y de ahi los interprete a acciones.
Haré que la configuracion a usar venga dada por variables de entorno, el main cargará esta informacion en el handler y este levantará el cliente de nats.

El main levantará el handler, este se subscribirá a un canal de control en nats y según reciba mensajes, estos tendrán acciones a desempeñar, el handler hará dispatch al usecase que toque en funcion de la acción que se haya pedido.
Voy a aprovechar el paquete commons para definir una serie de mensajes que puedan ser enviados desde este canal de control.

*Subida la verion v0.2 del proyecto*

Voy a crear un fichero .ENV en el que guardaré configuración relevante que usará la plataforma. Voy a empezar por el nombre del canal de NATS que va a atendender el monolito para recibir peticiones.
Para esto tambien voy a crear un paquete de configuracion que va a declarar y mantener una estructura "config" que va a ser propagada y utilizada por la plataforma.

----
Me acabo de dar cuenta de que he cometido un error garrafal leyendo el enunciado del ejercicio y he de replantear varios conceptos de base.
Pensé que había de programar un gestor de dispositivos que cada uno gestionaba varios sensores. Me di cuenta cuando al pensar el servicio de nats algunas cosas no me encajaban.

Voy a hacer una version hasta donde he llegado y cambiar de base algunas cosas.

Voy a comenzar haciendo el código que simule un sensor. Lo voy a hacer desde el código de iot-manager. Voy a mantener la estructura actual porque el dispositivo ha de aceptar dos peticiones del exterior - cambio de configuracion y cambio en una metrica.
Tengo pensado que el dispositivo vaya subiendo metricas a un tópico de jetstream y este podrá ser consumido desde el exterior. Luego habrá de quedarse escuchando a un tópico de nats y gestionar las peticiones que correspondan.

Pensandolo mejor, más allá de mantener una arquitectura por capas, creo voy a definir una estructura principal "sensor" y dentro de esta estructura tendré diferentes clientes para la tecnologia que quiera usar. Empezaré por la conexión de NATS.

Vale, ya tengo definido dentro de la carpeta iot-sensor la funcionalidad basica del sensor. He decidido dividirlo en 4 partes:
- Paquete sensor declara el componente del sensor y sus métodos implementados
- Paquete config que tendrá toda la configuracion necesaria para levantar el sensor, voy a suponer que le viene dada por variables ENV durante despliegue
- Paquete de clientes que cuenta con una implementacion de las tecnlogias que usa el sensor
- Paquete main que levantará las dependencias necesarias y ejecutará el sensor

*Subida la version v0.4 del proyecto*

Con esto queda programada la funcionalidad básica de subir métricas del sensor, quedaría hacer la configuración del stream de nats para lidiar con problemas de memoria, pero como mockup está bien así.

Ahora voy a continuar haciendo que el sensor atienda un tópico por el cual le lleguen ordendes de actualizar configuracion o de editar métricas.
Bueno para editar métricas primero deberia pensar en cómo se van a almacenar.

Las métricas las voy a almacenar en memoria dentro de un mapa, por el momento me permitirá mantenerlo simple y avanzar.

Con esto el handler queda terminado. El cliente de nats se encarga de subscribirse al tópico y deja como handler para el mensaje de nats el implementado en el fichero "handler.go"

Sin entrar en tests ni pruebas, por el momento el sensor va a quedar así. Ahora volveré a la carpeta iot-manager la cual voy a reconvertir en la pieza que simula la lectura de diferentes sensores.

*Subida la version v0.5 del proyecto*

Para el componente que simule la lectura periodica de metricas y la actualizacion de configuracion voy a hacerlo lo mas simple posible.
Va a ser un programa en go que se ejecute a través de un main, una flag va a determinar la operacion a realizar y el script se quedará leyendo métricas e imprimiendolas por pantalla
o bien actualizará una configuración y se apagará.

Esto no es lo suyo ya que cada vez que se ejecuta el script se ha de iniciar una nueva conexión con nats y levantar todo, pero es mas rapido que programar un servidor por http rest dedicado que mantenga una instancia levantada.

Ah y tambien añadir la posibilidad de editar métricas claro.

*Subida la version v0.6 del proyecto*

La pieza de iot-manager ya no sirve, la voy a deprecar.
Soy consciente de que iot-sensor y iot-sim comparten la manera de generar el cliente y la config pero lo prefiero asi para que puedan crecer por separado en el futuro.
La config sí la van a compartir por el momento, la muevo un nivel arriba.

Voy a declarar cada pieza como un modulo y unirlas bajo un go.work
Para que los cambios perduren y los modulos puedan importar correctamente el paquete commons voy a lanzar la release 1.0.0 para commons y despues una 1.1.0 para los otros modulos

*Subidas las versiones v1.0.0 y v1.1.0 del proyecto*

No consigo hacer que el proyecto mantenga bien las dependencias a un nivel de repositorio como seria un trabajo final en produccion.
La respuesta correcta es que para mantener este enfoque de piezas por modulos, el modulo comun que importan "commons" deberia estar en un repositorio a parte y ser mantenido a fuera.
Para no complicar mas la pracitca y mantenerlo todo junto, voy a añadir replaces en ambos go mod y voy a mantener un go work interno.

Voy a volver a hacer los tags y este será ahora el tag v1.0.0